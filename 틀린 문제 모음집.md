# 목차

- **Dynamic Programming**
- **Tree**
  - Binary Tree
- **Greedy**




# Dynamic Programming

#### 백준 17626 (라그랑주 승수법 문제)

- **라그랑주는 모든 자연수는 넷 혹은 그 이하의 제곱수의 합으로 표현될 수 있다고 증명했다.** 

  **예를 들어 26=5^2 + 1^2 이다. 자연수 n이 주어질 때, n을 최소 개수의 제곱수 합으로 표현하는 방법은?**

  이 문제는 시간 제한이 0.5초기 때문에, 모든 경우의 수를 구하려면 dp를 사용해야 한다. 

  문제는 점화식을 어떻게 표현할까 인데, 

  dp[0] = 0

  dp[1] = 1^2 = 1개

  dp[2] = 1^2 + 1^2 = 2개

  ....

  이런식으로 구할 수 있고, 규칙을 찾은 결과, dp[n]=min(dp[n-1]+1, dp[n-k^2] + dp[k^2])라고 표현할 수 있었다. 단, n이 제곱수일 경우 답은 1이다. 

  처음에는 왜 k^2인지 이해가 잘 안됐다. 

  dp[8]= dp[7]+1 / dp[6]+dp[2] / dp[5]+dp[3] / dp[4]+dp[4]

  위 네개에서 최소를 구해야 되는 것이 아닌가 생각했다. 

  그런데 이 문제를 더 잘게 쪼개보면 dp[k]가 제곱수일 경우에 값이 1로 가장 작은 수가 된다. 

  그렇다면 더 큰 수에서 생각을 해보자. 

  dp[101]이 있을 때, 최소 개수를 구할 수 있는 방법은 무엇일까?

  > dp[1]+dp[100]
  >
  > dp[2]+dp[99]
  >
  > dp[3]+dp[98]
  >
  > dp[4]+dp[97]
  >
  > ....
  >
  > 이런식으로 이어질 것이다. 
  >
  > 여기서 dp[4]=1, dp[2]=2이다. 그러면 dp[4]+dp[97]이 dp[2]+dp[99]보다 작다는 게 보장이 되야 위 점화식이 성립한다. 
  >
  > 이걸 더 잘게 쪼개보는 방식으로 생각해보았다. 
  >
  > dp[99]를 쪼개고 dp[97]을 쪼갤 때, 가장 작은 개수를 가지려면 제곱수가 포함되어야 할 것이다. 
  >
  > 제곱수가 포함되게 쪼개고, 또 쪼개고, 또 쪼개고 이런식으로 나아갈 수 있다. 
  >
  > 그렇다면 어찌되었든 제곱수를 포함한 값이 최소가 될 것이다. 
  >
  > 따라서, 항상 제곱수를 포함하게 만들어야 최소 개수가 성립된다는 것을 알 수 있다. 



# Tree

#### Binary Tree (Leetcode 783)

- **전순위, 중순위, 후순위 탐색**을 알고 있다면 쉬운 문제였다. 

  하지만, 실제 이론을 아는 것이랑 코드로 결과를 확인하는 것은 조금 괴리감이 있었던 것 같다. 

  나는 이론적으로 알고 있다고 생각했는데, 막상 실제 코드로 보니 새로워서 이렇게 정리하게 됐다. 

  이 문제의 핵심은 노드 간 차이를 최소화한다는 것에 있다. 

  그렇다면, 정렬이 된 상태의 binary tree에서 최소 간격을 가지는 노드를 어떻게 찾을 수 있을까?

  바로,

  **/현재 자신 노드보다 작은 왼쪽 노드들 중, 가장 큰 노드를 자신과 비교**

  **/현재 자신 노드보다 큰 오른쪽 노드들 중, 가장 작은 노드를 자신과 비교**

  이렇게 총 두가지 경우를 들 수 있다. 

  그렇다면 아래 그림의 화살표에서 pre value값을 갱신해가면서 위의 원하는 비교를 할 수 있는 탐색 방법은 무엇일까?

  바로 중순위 탐방이다. 

  **중순위 탐방을 이용하면, 위 두가지 조건을 모두 탐색할 수 있게 된다.** 

  **(pre value를 계속 갱신하는 것이 포인트이다.)**

  **<전순위 탐방>**

  ![image](https://user-images.githubusercontent.com/71866756/157698596-56d9ef7f-52a0-4b0e-800b-d04644c84b85.png)  

  **<중순위 탐방>**

  ![image](https://user-images.githubusercontent.com/71866756/157698614-e544d7ac-e175-4247-8a01-fa4adefd6dc3.png)

  **<후순위 탐방>**

  ![image](https://user-images.githubusercontent.com/71866756/157698628-6bc05670-aa54-494e-be47-caf055c7076f.png)

  

# Greedy

#### 백준 1285 (greedy와 brute force 섞은 문제)

- 이 문제는 NxN으로 행렬이 주어지고, 각 칸마다 동전이 앞/뒤로 놓여있을 때 동전 뒤집기를 통해 뒷면의 개수를 최소로 만드는 문제이다. 

  이 때, 뒤집기는 열/행 단위로 뒤집는다. 

  나는 처음에는 모든 경우의 수를 구하기에는 시간제한이 빡빡하다고 생각하여 모든 열과 행에 대해서 뒷면의 개수가 더 클 경우만 골라서 뒤집는 방법을 생각했었다. 

  하지만, 이는 접근부터가 잘 못 됐었다. 

  결국 접근법은 모든 행에 대해서 뒤집는 조합을 모두 찾고, 각 조합마다 열을 탐색하면서 뒷면이 더 많은 열을 뒤집으면 되는 문제였다. 

  애초에 행의 모든 조합을 찾았으면 다시 열을 뒤집고 다시 행을 뒤집는 바보같은 행위는 필요가 없었다. 

  따라서 bitmask를 이용해서 예를 들어 N=3일 때는 111~000까지 flag를 주고 모든 가능한 조합으로 뒤집었다. 

  그리고 열을 검사하면서 뒷면이 많으면 뒤집어야 하니 N-뒷면의 개수를 더해주고, 앞면이 많으면 뒷면의 개수를 더해주어 모든 경우에 대해서 값을 구했다. 

  최종적으로 그 중 가장 적은 개수를 구하면 정답!

#### 백준 9576 (greedy인데 정렬 기준이 중요함)

- 이 문제는 학생들마다 시작번호, 끝번호를 가지고 있고, 책의 개수가 정해져 있을 때 최대한 많은 학생에게 책을 나눠줘야 한다. 

  처음에는 시작번호를 오름차순 정렬하고, 시작번호가 같으면 끝번호를 오름차순 정렬해서 책 번호를 1번부터 끝까지 검사하면서 차례대로 넣는 방법을 선택했다.  

  그런데 이렇게 넣을 경우,

  1 1, 1 3, 2 2의 경우에 1 1 -> 1번책, 1 3-> 2번책을 주게 되면 마지막 2 2는 책을 받을 수 없게 되는 반례가 생긴다. 

  따라서 끝번호 기준으로 먼저 오름차순 정렬 & 시작 번호 기준 오름차순 정렬로 문제를 풀어야 했다. 끝번호가 제일 작은 사람에게 시작번호부터 안 빌려준 책이 있다면 빌려주는 방식으로 문제를 해결한다. 

  그러면 1 1 -> 1번책, 2 2 -> 2번책, 1 3 -> 1번, 2번을 빌려줬으니 3번책을 빌려준다. 

  이 때, 빌려줬는지 아닌지 확인하는 벡터를 하나 만들어주었다.  
